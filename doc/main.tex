\documentclass{book}

\usepackage{graphicx}
\usepackage{hyperref}

\title{\textbf{jettl} \\ An Interface-Composition based \\ LabVIEW Actor Model}
\author{Nathan Davis}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\section{A Community Effort}
\label{sec:community-effort}

This document is a community effort to create a LabVIEW Actor Model that is interface-composition based.
The goal is to create a design pattern that is easy to use, understand, and extend.
This document is a living document, and contributions are welcome.

Along with reading this document, the model will be best understood with examples that occur in projects.
To show the power of the interface-composition based approach, in particular, examples that are difficult in DQMH, Actor Framework, and other frameworks will be of upmost importance.
This document is not meant to be a complete guide to the jettl framework, but rather a starting point for understanding the design philosophy and implementation details.

\section{Introduction}
\label{sec:introduction}

“The fundamental situation is, that we don't know much and some of it's wrong.”
-Carl Hewitt, creator of Actor Model

Strictly interface composition based asynchronous actor oriented design pattern for LabVIEW Applications.
jettl also has the newer banners for vis. Easy adoption for the new age of LV developers.
State pattern with decorators.
It is interface composition, so stick with the same rule set for naming methods

\section{Class Hierarchy}
\label{sec:class-hierarchy}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/class-hierarchy}
    \caption{jettl Class Hierarchy.}
    \label{fig:jettl-class-hierarchy}
\end{figure}

Fig~\ref{fig:jettl-class-hierarchy} shows the class hierarchy of jettl.
In particular, there exist design patterns such as the Strategy Pattern, State Pattern, and Decorator Pattern.

\section{Actors}
\label{sec:actors}

\subsection{Actor Benefits}
\label{subsec:actor-benefits}

\begin{itemize}
    \item jettl Queue Actor: Obtains and releases its own references
    \item jettl Event Actor: Creates, Registers, Unregisters, and Destroys its own references
\end{itemize}


\section{Future Scope}
\label{sec:future-scope}

Creating an actor is NOT connected to the actor that creates it.
Rather, this actor exists on its own in the “liquid” message transport.
The overall “application” has access to the actor's reference (unique message address)

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/labview_dmitry_message _transport}
    \caption{LabVIEW Actor Framework Message Transport.}
    \label{fig:message-transport}
\end{figure}

As shown in Fig~\ref{fig:message-transport}, it is as though the actors are just objects that “float” in this “liquid” messaging transport.
So that way you can perform this pub-sub messaging.
The objects are linked together by “who creates who”.

Same as with the pub-sub pattern, everything is a publisher-subscriber.
It's just that most relationships are just one way.
Same with Git, the philosophy is that all branches are created equal


\section{Unit Testing}
\label{sec:unit-testing}

This model is interface-composition based, so unit testing is built in.
In effect, instead of wrapping the Queue Base with your developed class, you can wrap the Queue Base with a Queue Base Debug class, which is wrapped with your developed class.
This occurs since these all inherit from the same Queue jettl interface.

This allows for arbitrary wrapping of classes, which is a powerful feature of the interface-composition based design pattern.

For the wrapping, it is as easy as have to wire in the object in the decorator method for debugging??

\section{Debugging}
\label{sec:debugging}

\subsection{Displaying Method Execution}
\label{subsec:displaying-method-execution}

What a log for which methods are executed, instead of the dialog popups

Two project conditional blocks:
\begin{enumerate}
    \item Occurs in all methods
    \item Occurs only in message specific methods
\end{enumerate}

These conditionals occur in Self Actor.lvclass.
If either conditional is true, debug panel that displays the names of actors (columns), along with timestamps (rows) of when methods (data) are executed.
Think discrete time water fall display.

\section{Git}
\label{sec:git}

This might be of interest for submodules in git for LabVIEW.
Find here: \href{https://www.youtube.com/watch?v=iv7WwDgyb0U}{Git Submodules: An Alternative Approach to Code Reuse - Greg Payne - GDevCon2}.

In the repos, use the tag to have different "stable" versions of the repo such as v0.1.1 or v3.8.3
This allows others to easily look at the different versions of the repo without much thought.
This could also help with submodules that are referenced in other repos.
Check this video near the end for reference: \href{https://www.youtube.com/watch?v=tRZGeaHPoaw&list=PLvDxiIkwuMQs0Uu6AIhTGqXahndMmfUyx&index=19}{Git and GitHub Tutorial for Beginners}

\section{Naming Conventions}
\label{sec:naming-conventions}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/dmitry_liskov_sub_principle}
    \caption{This image shows the naming convention for LabVIEW classes and methods.}
    \label{fig:dmitry-liskov-sub-principle}
\end{figure}

Noting that Fig~\ref{fig:dmitry-liskov-sub-principle} shows the naming convention for LabVIEW classes and methods.
\begin{itemize}
    \item{Library-Name.lvlib}
    \item{Interface-Name.lvclass}
    \item{Class-Name.lvclass (control is capital by default!)}
    \item{method-Name.vi}
    \item{control-Name.ctl (this control, which is not tied to a class is lowercase!)}
\end{itemize}

\noindent Note: Avoid underscores and spaces.


\section{Examples}
\label{sec:examples}

\subsection{Hello World}
\label{subsec:hello-world}

Hello World Example:
Don't need to send yourself Teardown for Hello World.. just have Teardown method itself at the end of the Hello World Msg.

\subsection{Nested Actors}
\label{subsec:nested-actors}

\href{https://youtu.be/N6X9KyJJ-D4?feature=shared}{2018 NIWeek Allen C Smith Efficient Actor Framework Development}
25:58
Teardown vs Orderly Teardown:
Allen wanted a “Stop Nested Actors Msg”, SLM against.
There include two methods: Event Nested Teardown.vi and Queue Nested Teardown.vi.
These two methods are used to teardown the respective nested actors.

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{figures/Hello-World}
    \caption{This image shows the hello world example.}
    \label{fig:hello-world}
\end{figure}

\subsection{Sending Event Message}
\label{subsec:sending-event-message}

Button press sends message to Self (queue actor).
Queue actor internally sends a string indicator Event which occurs in event loop.


\section{Design Patterns}
\label{sec:design-patterns}

\subsection{State Pattern}
\label{subsec:state-pattern}

\noindent Context:

\quad Method.vi (just a wrapper for Method.vi “State”).\footnote{Best Practice: use this Method.vi in other methods, rather than the Method.vi “State” itself}

\noindent State.lvclass (interface):

\quad Concrete State.lvclass

\quad Method.vi “State”

\subsubsection{State Pattern Privacy}
\label{subsubsec:state-pattern-privacy}

Context classes should be private, since only interface objects should be composed into a class.
Dependency Inversion Principle.
Since the context class is private to the library it is in (and the State Interface with its concrete state classes), public static dispatch methods can be used in the context class AND concrete state classes without worrying that they'll be used outside the library since the context class is private.

\subsection{Memento Pattern}
\label{subsec:memento-pattern}

When saving the state of an actor, the Memento Pattern is used.
Instead of sending the entire actor state in Actor Last Ack Msg, there should be another dedicated message that sends the actors state to the calling actor.
This has not been done, but it is a good idea to implement this in the future.

Memento, actors shouldn't know about each other, so if the state of a nested is to be saved, then there is a separate message for this since last ack shouldn't know about this.
Rather, this specialty message couples with last ack if the developer wants this functionality.

\subsection{Decorator Pattern}
\label{subsec:decorator-pattern}



\subsection{Strategy Pattern}
\label{subsec:strategy-pattern}



\subsection{Observer Pattern}
\label{subsec:observer-pattern}

Actors references cannot be passed between actors or helper loops.
They are intentionally abstracted away from the developer.
Now, because helper loops are async and own their own references.
Their references can be passed around the actor tree.
This provides a modular way of sharing async references, following the observer pattern.


\section{Event Actors}
\label{sec:event-actors}

This is to declutter the actor by offloading certain tasks such as panel display or subprocesses that do not require an additional actor to be created.
Since the Event Actors are not dependent on the Queue Actor, we can unit test an Event Actor.

Event Actors are created using Event Create.vi, where the wired in object optionally has a method for bundling in the necessary private data.

\subsection{Event Actor Best Practices}
\label{subsec:event-actor-best-practices}

References should not change after they are created.

\subsection{Event Actor Benefits}
\label{subsec:event-actor-benefits}

Event are designed to be reusable and modular.
Event Actors are not tied to the Queue Actor that creates them.
Furthermore, Queue Actors should not depend on Event Actors.

These can be orphan processes i.e. they are not tied to the lifetime of the actor that creates them.

\subsection{Window and Subpanel Event Actors}
\label{subsec:panels}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/justACS_ui_events}
    \caption{This image shows the UI events in LabVIEW.}
    \label{fig:justacs-ui-events}
\end{figure}

Split the events as controls and indicators as shown in Fig~\ref{fig:justacs-ui-events}.

\subsection{Synchronous Event Actor}
\label{subsec:synchronous-event-actor}

Since Queue Actors should always be ready to dequeue messages, it should not wait on a response.
Rather, the Queue Actor should create the Synchronous Event Actor.
When the Event Actor is waiting for response, that's okay since when the event actor is waiting, it is also ready to teardown whenever since it is always waiting for an event.

\subsection{Event Observer}
\label{subsec:event-observer}

A Queue Actor has in its project an Event Actor that another Actor can create. And here can send its Event Actor Ref to the Libraries Queue Actor to pump messages across the tree.
For reusability, a Queue Actor has in its project the Event Actor that another Actor can create.
And here can send its Event Actor Ref to the Libraries Queue Actor to pump messages across the tree.

\begin{itemize}
    \item NIAF: 2-Dimensional tree hierarchy
    \item Base jettl: 3-Dimensional hierarchy
\end{itemize}

In Base Queue, a tree hierarchy of Queue Actors (follows 2-dimensional NIAF messaging scheme) and a single layer tree hierarchy of Event Actors for a given Queue Actor.
The 3-Dimensional aspect comes from Event Actors being able to share their references with other Queue Actors and/or Event Actors.
This allows these latter Actors to send events to the respective Event Actor who has shared their reference.
This “messaging across the tree” in three dimensions can occur giving rise to a type of observer pattern (publisher/subscriber).

\section{Notifier Actors}
\label{sec:notifier-actors}

Notifier Actors are created using Notifier Create.vi, where the wired in object optionally has a method for bundling in the necessary private data.

\subsection{Notifier Periodic}
\label{subsec:notifier-periodic}

This could be an event actor, but notifiers work well with timing.
If it was an event actor, then the event actor would have to wait for the next event to occur via the timeout case in the event loop.
But there would be interruptions in the event loop, which would cause the event actor to not be able to send messages at the correct time.

Private Data:
\begin{itemize}
    \item Iteration (0 = infinite) (U32)
    \item Period (ms) (default 1000) (U32?) (cannot = 0)
    \item Initial Wait (ms) (default 0) (U32?) (cannot = 0)
\end{itemize}

Along with the Stage Pattern used in the Base Notifier.lvclass, State Pattern can be used in the Notifier Periodic.lvclass such as
\begin{itemize}
    \item Idle State
    \item Running State
\end{itemize}


\section{Messaging}
\label{sec:messaging}

All messages come from an interface and follow ISP where one message belongs to one interface.
If there is a naming issue, that is a good thing.
It means in the dependencies, you should be packaging modules so you don't run into naming issues.


All messages are interface messages.
Note, they do not need to be implemented.

Actor messages error on generation of message.
Error when creating a message and wiring in the interface object as an input, the message scripting doesn't know how to differentiate the class input and the parameter input.

\subsection{Private Messages}
\label{subsec:private-messages}

Private messages that aren't exposed to external callers: Library access scope.
To conform to this, the Last Ack messages should be private messages to the Queue Base class.
This is because the Last Ack messages are not intended to be used by external callers.
Further, this should also be done for the Update Queue Nested message. This should not be used by external callers, but rather only by the Event Base class.

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{figures/Need_for_error_msg}
    \caption{This is the Error message in jettl. This is a custom error message that occurs when an error occurs asynchronously.}
    \label{fig:error-msg}
\end{figure}

\subsection{Messages Up and Down the Tree}
\label{subsec:messages-up-and-down-tree}

When messages are sent up the queue tree, followed by being sent down the tree, the developer could consider using event actors to message across the tree.
This is a direct use case for using an Event Actor.
Sharing the event actor reference to the necessary Queue Actors or Event Actors for direct communication.
This is the power of Event Actors.
Gives rise to the Observer (Pub-Sub) Pattern, sending NOT Msgs, but Events across the tree.

\subsection{Messages with Type Definitions}
\label{subsec:messages-with-type-definitions}

Type definitions as inputs SHOULD be in the library, not the class they're implemented in.
This is fundamentally an exercise in dependency inversion.

Cluster message with type def inside of the library.
Good practice to put the type def here and NOT in the class that implements the message.
This takes care of otherwise awful circular dependencies.

\section{Tools}
\label{sec:tools}

\subsection{Scripting}
\label{subsec:scripting}

Tips:
Go through and replace all the Opens and Traverse with the hidden gem.
User groups for the scripting (quick drop, right click, etc.).

\subsubsection{Right Click Message Creation}


\section{TODO}
\label{sec:todo}

In the DD methods, because they are not required to be overridden, have functionality within them that calls the Self Actor method (some kind of checking mechanism?).

Actor interface methods (all implemented with default functionality) to have the *new* (Actor Interface) Read Actor DD method that reads from the Dev Actor the Self Actor class and performs that interface function, then bundles back in with the Setup method.

Do this for all for the default behavior.

Note this is breaking the contract for interface DD methods not needing to be overridden.

Instead of the Setup method, create a new Actor Write method which ONLY Writes to the Actor. This can also be put inside the Setup method as a first step, the setup code follows after

State Enter Core and State Exit Core are NOT check marked.
That way the developer does not need to override, just to have no functionality anyway.
Read State and Write State do because they'll have functionality.

\section{Errors}
\label{sec:errors}

In frameworks, errors are fundamental to the program's operation. They are not just incidental issues but rather integral to the design and flow of the application.
jettl has an error object in the private data of the jettl object. At the end of the method, the error object is unbundled and checked for errors before teardown.

Error philosophy: Errors occur ONLY from unexpected events.
For example, the error case in Msg.vi: in the case structure, a custom error saying that a message could not be executed occurs when 'message name' occurs for 'actor name'. This is unexpected behavior since this SHOULD be known at edit time. This is a legit error.

'That was handled, or I wouldn't have been called' - SLM (\href{https://www.youtube.com/watch?v=00TZxeyt8_A}{The Errors of our Ways | Stephen Loftus-Mercer GDevCon N.A. 2021: 52:08})

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/method-template}
    \caption{Method template. This has no error terminals, and the error cluster is handled internally. This is a different approach to error handling in LabVIEW methods.}
    \label{fig:method-template}
\end{figure}
% have the actual method template here, from the example. These are scripted and autogenerated when one creates an actor.

Wouldn't this make the API more beautiful and easy to understand? Having just the object wire come out of the method, and ONLY the object wire coming out of the method?
I suppose, adopting the OO paradigm.
Instead of having the error cluster inside the objects class data.
Instead, it's a dedicated “error cluster” shared for every single object in use.
Encourages data flow since unbundling of errors will always occur.
It's a step in the right direction having no “error input” for methods.
Now it's time to get rid of the error out.
It's almost like branching an objects wire, in a way. There should only be one thing coming out of a method.

\section{Example}
\label{sec:example}

\subsection{Dev Actor}
\label{subsec:dev-actor}

Merge Error and Override Error are decorators used.
Otherwise, the other DD methods are trivial and only used once.


\section{Creation}
\label{sec:creation}

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{figures/Creation}
    \caption{This image shows the creation of Base Actors.}
    \label{fig:creation}
\end{figure}

Queue Actor
\begin{itemize}
    \item Has One Caller Queue Actor
    \item Is a Nested Queue Actor of Queue Actor
    \item Is a Self Queue Actor
\end{itemize}

Event Actor
\begin{itemize}
    \item Has One Caller Queue Actor
    \item Is a Nested Event Actor of Queue Actor
    \item Is a Self Event Actor
\end{itemize}

Framework constraint:
A Queue Actor can create both Queue Actors and Event Actors whereas an Event Actor cannot create either.
The Event Actor can queue itself either Queue Create or Event Create messages, but this goes to the Queue Actor to handle these.
The handling does not occur in the Event Actor since the Event Actor cannot create.

A future question: Should Launch.vi exist outside the Queue Base class?
If it does, then Queue Base can be marked as a private class, and the Launch.vi can be public.

Only Queue Actors can create Queue Actors and Event Actors.
Event actors cannot create either.
Further, because of these rules, only queue actors can receive the Last Ack from Nesteds.
This is respectively the Queue Last Ack and Event Last Ack.
Event Actors cannot receive either Last Ack.
These Last Ack messages are not used by the developer.
These occur in the framework itself, though functionality can be wrapped in the developed queue actor.


\section{PPL Support}
\label{sec:ppl-support}

PPLs is not currently supported in jettl.
This otherwise should be a simple task to implement.
How to change a class to use the PPL version of jettl is to change the implemented interface to the PPL one and compose in the PPL Interface.

For more information on PPLs, Darren Nattinger and Derrick Bommarito have excellent content on this:
\begin{itemize}
    \item \href{https://forums.ni.com/t5/Community-Documents/Debugging-Symptoms-Packed-Project-Library-PPL-Dependencies/ta-p/4107786}{Debugging Symptoms - Packed Project Library PPL Dependencies - Searching for Dependencies Dialog When Running Executable}
    \item \href{https://forums.ni.com/t5/LabVIEW/PPL-Namespaced-Dependencies-Strategy-Design-Discussion/td-p/4276248}{PPL Namespaced Dependencies - Strategy/Design Discussion - Development Issues}
    \item \href{https://www.youtube.com/watch?v=HKcEYkksW_o}{LUDICROUS ways to Fix Broken LabVIEW Code with Darren Nattinger | GDevConNA 2022}
\end{itemize}

Further points include:
\begin{itemize}
    \item Ensure xnodes are not used in jettl.
    \item Get rid of all malleable vis (.vim extension)
\end{itemize}


\section{Opinionated Design Choices}
\label{sec:opinionated-design-choices}

\subsection{Color Scheme}
\label{subsec:color-scheme}

"Look down at the green grass, look up to the blue sky, and look further to the purple galaxy."
\begin{itemize}
    \item Purple Library: RGB (166,153,182)
    \item Blue Interface: RGB (104,136,190)
    \item Green Class: RGB (110,149,108)
\end{itemize}

\subsection{Access Scope}
\label{subsec:access-scope}

Only public and private.
Interfaces, classes, and methods have text in the icon/banner that are black for public and red for private.

\subsection{Errors}
\label{subsec:errors}

Except the error that could potentially occur at the end of Queue Actor.vi and Event Actor.vi, no error goes unrecognized.
Why are there are so many error case structures?
All methods in Base jettl are assumed to run unconditionally when they are called.
Also, no serialization of errors.
Instead, it is serialization of the object wire since internally, the class on the interface object in the private data has an error cluster.
The merge errors method (which internally has the Is Error.vi), dictating if Base jettl should enter the respective Error State.


\end{document}